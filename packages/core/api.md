## API Report File for "@simplux/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Action } from 'redux';
import type { AnyAction } from 'redux';
import { Reducer } from 'redux';
import { Store } from 'redux';

// @public (undocumented)
export type _AtomicObject = Promise<unknown> | Date | RegExp | Boolean | Number | String;

// @public
export function createEffect<TEffectFunction extends (...args: any[]) => any>(effect: TEffectFunction): SimpluxEffect<TEffectFunction>;

// @public
export function createEffects<TEffectDefinitions extends SimpluxEffectDefinitions>(effects: TEffectDefinitions): SimpluxEffects<TEffectDefinitions>;

// @public
export function createMutations<TState, TMutations extends MutationDefinitions<TState>>(simpluxModule: SimpluxModuleMarker<TState>, mutationDefinitions: TMutations): SimpluxMutations<TState, TMutations>;

// @public
export function createSelectors<TState, TSelectorDefinitions extends SelectorDefinitions<TState>>(simpluxModule: SimpluxModuleMarker<TState>, selectorDefinitions: TSelectorDefinitions): SimpluxSelectors<TState, TSelectorDefinitions>;

// @public
export function createSimpluxModule<TState>(config: SimpluxModuleConfig<TState>): SimpluxModule<TState>;

// @public
export function createSimpluxModule<TState>(name: string, initialState: TState): SimpluxModule<TState>;

// @internal
export interface _EffectMockDefinition {
    // (undocumented)
    readonly effectToMock: Function;
    // (undocumented)
    readonly mockFn: Function;
}

// @public
export type FunctionSignature<TFunction extends (...args: any[]) => any> = _NonFunctionProperties<TFunction> extends never ? TFunction : TFunction extends (...args: infer TArgs) => infer TReturn ? (...args: TArgs) => TReturn : never;

// @internal
export function _getEffectMockDefinitionsInternal(): _EffectMockDefinition[];

// @internal
export function _getInternalReduxStoreProxy(): _InternalReduxStoreProxy;

// @public
export function getSimpluxReducer(): Reducer;

// @public (undocumented)
export type _IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B;

// @public
export type Immutable<T> = T extends _AtomicObject ? T : _IsImmutable<T> extends true ? T : T extends ReadonlyMap<infer K, infer V> ? ReadonlyMap<Immutable<K>, Immutable<V>> : T extends ReadonlySet<infer V> ? ReadonlySet<Immutable<V>> : T extends object ? {
    readonly [K in keyof T]: Immutable<T[K]>;
} : T;

// @internal (undocumented)
export interface _InternalReduxStoreProxy {
    // (undocumented)
    actionsToDispatchOnStoreChange: Action[];
    // (undocumented)
    dispatch: Store['dispatch'];
    // (undocumented)
    getState: () => any;
    // (undocumented)
    id: number;
    // (undocumented)
    subscribe: Store['subscribe'];
    // (undocumented)
    subscribers: {
        handler: () => void;
        unsubscribe: () => void;
    }[];
}

// @public (undocumented)
export type _IsAtomicObject<T> = T extends _AtomicObject ? true : false;

// @public (undocumented)
export type _IsImmutable<T> = _IsAtomicObject<T> extends true ? true : _IsImmutableArray<T> extends true ? true : _IsImmutableObject<T> extends true ? true : false;

// @public (undocumented)
export type _IsImmutableArray<T> = T extends unknown[] ? false : T extends readonly (infer U)[] ? {
    [K in keyof T]: _IsImmutable<U>;
}[number] extends true ? true : false : false;

// @public (undocumented)
export type _IsImmutableObject<T> = T extends object ? Exclude<keyof T, _ReadonlyKeys<T>> extends false ? {
    [K in keyof T]: _IsImmutable<T[K]> extends true ? true : false;
}[keyof T] extends true ? true : false : false : false;

// @public (undocumented)
export type _IsMutable<T> = T extends _AtomicObject ? true : T extends _MutableArray<T> ? true : T extends object ? Exclude<keyof T, _WritableKeys<T>> extends never ? {
    [K in keyof T]: _IsMutable<T[K]> extends true ? true : false;
}[keyof T] extends true ? true : false : false : true;

// @internal
export function _isSimpluxEffect<TFunction extends (...args: any[]) => any, TOther>(object: SimpluxEffectMarker<TFunction> | TOther): object is SimpluxEffect<TFunction>;

// @internal
export function _isSimpluxModule<TState, TOther>(object: SimpluxModuleMarker<TState> | TOther): object is SimpluxModule<TState>;

// @internal
export function _isSimpluxMutation<TState, TArgs extends any[], TOther>(object: SimpluxMutationMarker<TState, TArgs> | TOther): object is SimpluxMutation<TState, TArgs>;

// @internal
export function _isSimpluxSelector<TState, TArgs extends any[], TReturn, TOther>(object: SimpluxSelectorMarker<TState, TArgs, TReturn> | TOther): object is SimpluxSelector<TState, TArgs, TReturn>;

// @public
export type Mutable<T> = T extends _AtomicObject ? T : _IsMutable<T> extends true ? T : T extends readonly (infer U)[] ? Mutable<U>[] : T extends ReadonlyMap<infer K, infer V> ? Map<Mutable<K>, Mutable<V>> : T extends ReadonlySet<infer V> ? Set<Mutable<V>> : T extends object ? {
    -readonly [K in keyof T]: Mutable<T[K]>;
} : T;

// @public (undocumented)
export type _MutableArray<T> = T extends readonly (infer U)[] ? Mutable<U>[] : never;

// @public
export type MutationDefinition<TState> = (state: TState, ...args: any) => TState | void;

// @public
export interface MutationDefinitions<TState> {
    // (undocumented)
    [name: string]: MutationDefinition<TState>;
}

// @public (undocumented)
export type _NonFunctionProperties<TFunction extends Function> = Exclude<keyof TFunction, keyof Function>;

// @public (undocumented)
export type _ReadonlyKeys<T> = {
    [P in keyof T]-?: _IfEquals<{
        [Q in P]: T[P];
    }, {
        -readonly [Q in P]: T[P];
    }, never, P>;
}[keyof T];

// @public
export type ResolvedMutation<TState, TMutation extends MutationDefinition<TState>> = TMutation extends (state: TState, ...args: infer TArgs) => TState | void ? SimpluxMutation<TState, TArgs> : never;

// @public
export type ResolvedSelector<TState, TSelectorDefinition extends SelectorDefinition<TState, ReturnType<TSelectorDefinition>>> = TSelectorDefinition extends (state: Immutable<TState>, ...args: infer TArgs) => infer TReturn ? SimpluxSelector<TState, TArgs, TReturn> : never;

// @public
export type ResolvedStateChangeHandler<TState, THandler> = THandler extends (state: Immutable<TState>) => void ? (state: Immutable<TState>) => void : StateChangeHandler<TState>;

// @public
export type SelectorDefinition<TState, TReturn> = (state: Immutable<TState>, ...args: any) => TReturn;

// @public
export interface SelectorDefinitions<TState> {
    // (undocumented)
    [name: string]: SelectorDefinition<TState, any>;
}

// @public
export function setReduxStoreForSimplux<TState>(storeToUse: Store<TState>, simpluxStateGetter: (rootState: TState) => any): () => void;

// @public
export const SIMPLUX_EFFECT = "[SIMPLUX_EFFECT]";

// @public
export const SIMPLUX_MODULE = "[SIMPLUX_MODULE]";

// @public
export const SIMPLUX_MUTATION = "[SIMPLUX_MUTATION]";

// @public
export const SIMPLUX_SELECTOR = "[SIMPLUX_SELECTOR]";

// @public
export type SimpluxEffect<TFunction extends (...args: any[]) => any> = FunctionSignature<TFunction> & SimpluxEffectMarker<TFunction> & SimpluxEffectMetadata;

// @public
export interface SimpluxEffectDefinitions {
    // (undocumented)
    readonly [name: string]: (...args: any[]) => any;
}

// @public
export interface SimpluxEffectMarker<TFunction extends (...args: any[]) => any> {
    readonly [SIMPLUX_EFFECT]: TFunction;
}

// @public (undocumented)
export interface SimpluxEffectMetadata {
    readonly effectName: string;
}

// @public
export type SimpluxEffects<TEffectDefinitions extends SimpluxEffectDefinitions> = {
    [effectName in keyof TEffectDefinitions]: SimpluxEffect<TEffectDefinitions[effectName]>;
};

// @public
export interface SimpluxModule<TState> extends SimpluxModuleMarker<TState> {
    // @internal
    readonly $simpluxInternals: _SimpluxModuleInternals<TState>;
    readonly setState: (state: Immutable<TState>) => void;
    readonly state: SimpluxSelector<TState, [], Immutable<TState>>;
    readonly subscribeToStateChanges: SubscribeToStateChanges<TState>;
}

// @public
export interface SimpluxModuleConfig<TState> {
    // (undocumented)
    readonly initialState: TState;
    // (undocumented)
    readonly name: string;
}

// @internal
export interface _SimpluxModuleInternals<TState> {
    readonly dispatch: (action: AnyAction) => void;
    readonly getReducer: () => Reducer;
    readonly getState: () => Immutable<TState>;
    lastSelectorId: number;
    mockStateValue: TState | undefined;
    readonly mutationMocks: {
        [mutationName: string]: (...args: any[]) => TState;
    };
    readonly mutations: MutationDefinitions<TState>;
    readonly name: string;
    readonly selectorMocks: {
        [selectorId: number]: (...args: any[]) => TState;
    };
}

// @public
export interface SimpluxModuleMarker<TState> {
    readonly [SIMPLUX_MODULE]: TState;
}

// @public
export interface SimpluxMutation<TState, TArgs extends any[]> extends SimpluxMutationMarker<TState, TArgs> {
    // (undocumented)
    (...args: TArgs): TState;
    readonly asAction: (...args: TArgs) => {
        type: string;
        args: TArgs;
    };
    readonly mutationName: string;
    // @internal
    readonly owningModule: SimpluxModule<TState>;
    // @internal
    readonly type: string;
    readonly withState: (state: TState, ...args: TArgs) => TState;
}

// @public
export interface SimpluxMutationMarker<TState, TArgs extends any[]> {
    readonly [SIMPLUX_MUTATION]: [TState, TArgs];
}

// @public
export type SimpluxMutations<TState, TMutations extends MutationDefinitions<TState>> = {
    readonly [name in keyof TMutations]: ResolvedMutation<TState, TMutations[name]>;
};

// @public
export interface SimpluxSelector<TState, TArgs extends any[], TReturn> extends SimpluxSelectorMarker<TState, TArgs, TReturn> {
    // (undocumented)
    (...args: TArgs): TReturn;
    // @internal
    readonly owningModule: SimpluxModule<TState>;
    // @internal
    readonly selectorId: number;
    readonly selectorName: string;
    readonly withState: (state: Immutable<TState>, ...args: TArgs) => TReturn;
}

// @public
export interface SimpluxSelectorMarker<TState, TArgs extends any[], TReturn> {
    readonly [SIMPLUX_SELECTOR]: [TState, TArgs, TReturn];
}

// @public
export type SimpluxSelectors<TState, TSelectorDefinitions extends SelectorDefinitions<TState>> = {
    readonly [name in keyof TSelectorDefinitions]: ResolvedSelector<TState, TSelectorDefinitions[name]>;
};

// @internal (undocumented)
export interface _SimpluxStore {
    // (undocumented)
    dispatch: Store['dispatch'];
    // (undocumented)
    getReducer: <T = any>(name: string) => Reducer<T>;
    // (undocumented)
    getState: () => any;
    // (undocumented)
    rootReducer: Reducer;
    // (undocumented)
    setReducer: <T = any>(name: string, reducer: Reducer<T>) => void;
    // (undocumented)
    subscribe: Store['subscribe'];
}

// @public
export type StateChangeHandler<TState> = (state: Immutable<TState>, previousState: Immutable<TState>) => void;

// @public
export interface StateChangeHandlerOptions {
    readonly shouldSkipInitialInvocation?: boolean;
}

// @public
export interface StateChangeSubscription<TState, THandler extends StateChangeHandler<TState>> extends Subscription {
    readonly handler: ResolvedStateChangeHandler<TState, THandler>;
}

// @public
export type SubscribeToStateChanges<TState> = <THandler extends StateChangeHandler<TState>>(handler: THandler, options?: StateChangeHandlerOptions) => StateChangeSubscription<TState, THandler>;

// @public
export interface Subscription {
    readonly unsubscribe: () => void;
}

// @public (undocumented)
export type _WritableKeys<T> = {
    [P in keyof T]-?: _IfEquals<{
        [Q in P]: T[P];
    }, {
        -readonly [Q in P]: T[P];
    }, P>;
}[keyof T];


// (No @packageDocumentation comment for this package)

```
