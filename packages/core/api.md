## API Report File for "@simplux/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AnyAction } from 'redux';
import { Reducer } from 'redux';
import { Store } from 'redux';

// @public
export function createEffect<TEffectFunction extends (...args: any[]) => any>(effect: TEffectFunction): SimpluxEffect<TEffectFunction>;

// @public
export function createEffects<TEffectDefinitions extends EffectDefinitions>(effects: TEffectDefinitions): SimpluxEffects<TEffectDefinitions>;

// @public
export function createMutations<TState, TMutations extends MutationDefinitions<TState>>(simpluxModule: SimpluxModule<TState>, mutationDefinitions: TMutations): SimpluxMutations<TState, TMutations>;

// @public
export function createSelectors<TState, TSelectorDefinitions extends SelectorDefinitions<TState>>(simpluxModule: SimpluxModule<TState>, selectorDefinitions: TSelectorDefinitions): SimpluxSelectors<TState, TSelectorDefinitions>;

// @public
export function createSimpluxModule<TState>(config: SimpluxModuleConfig<TState>): SimpluxModule<TState>;

// @public
export function createSimpluxModule<TState>(name: string, initialState: TState): SimpluxModule<TState>;

// @public (undocumented)
export interface EffectDefinitions {
    // (undocumented)
    [name: string]: (...args: any[]) => any;
}

// @public
export type EffectFunction<TEffect extends SimpluxEffect<(...args: any[]) => any>> = (...args: Parameters<TEffect>) => ReturnType<TEffect>;

// @public
export interface EffectMockDefinition {
    // (undocumented)
    effectToMock: Function;
    // (undocumented)
    mockFn: Function;
}

// @public
export function getInternalReduxStoreProxy(): InternalReduxStoreProxy;

// @public
export function getMockDefinitionsInternal(): EffectMockDefinition[];

// @public
export function getSimpluxReducer(): Reducer;

// Warning: (ae-forgotten-export) The symbol "AtomicObject" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "IsImmutable" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type Immutable<T> = T extends AtomicObject ? T : IsImmutable<T> extends true ? T : T extends ReadonlyMap<infer K, infer V> ? ReadonlyMap<Immutable<K>, Immutable<V>> : T extends ReadonlySet<infer V> ? ReadonlySet<Immutable<V>> : T extends object ? {
    readonly [K in keyof T]: Immutable<T[K]>;
} : T;

// @public (undocumented)
export interface InternalReduxStoreProxy {
    // (undocumented)
    dispatch: Store['dispatch'];
    // (undocumented)
    getState: () => any;
    // (undocumented)
    id: number;
    // (undocumented)
    subscribe: Store['subscribe'];
    // (undocumented)
    subscribers: {
        handler: () => void;
        unsubscribe: () => void;
    }[];
}

// @public
export function isSimpluxModule<TState, TOther>(object: SimpluxModule<TState> | TOther): object is SimpluxModule<TState>;

// Warning: (ae-forgotten-export) The symbol "IsMutable" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type Mutable<T> = T extends AtomicObject ? T : IsMutable<T> extends true ? T : T extends readonly (infer U)[] ? Mutable<U>[] : T extends ReadonlyMap<infer K, infer V> ? Map<Mutable<K>, Mutable<V>> : T extends ReadonlySet<infer V> ? Set<Mutable<V>> : T extends object ? {
    -readonly [K in keyof T]: Mutable<T[K]>;
} : T;

// @public (undocumented)
export type MutationDefinition<TState> = (state: TState, ...args: any) => TState | void;

// @public (undocumented)
export interface MutationDefinitions<TState> {
    // (undocumented)
    [name: string]: MutationDefinition<TState>;
}

// @public (undocumented)
export type ResolvedMutation<TState, TMutation extends MutationDefinition<TState>> = TMutation extends (state: TState, ...args: infer TArgs) => TState | void ? SimpluxMutation<TState, TArgs> : never;

// @public (undocumented)
export type ResolvedSelector<TState, TSelectorDefinition extends SelectorDefinition<TState, ReturnType<TSelectorDefinition>>> = TSelectorDefinition extends (state: Immutable<TState>, ...args: infer TArgs) => infer TReturn ? SimpluxSelector<TState, TArgs, TReturn> : never;

// @public (undocumented)
export type ResolvedStateChangeHandler<TState, THandler> = THandler extends (state: Immutable<TState>) => void ? (state: Immutable<TState>) => void : StateChangeHandler<TState>;

// @public (undocumented)
export type SelectorDefinition<TState, TReturn> = (state: Immutable<TState>, ...args: any) => TReturn;

// @public (undocumented)
export interface SelectorDefinitions<TState> {
    // (undocumented)
    [name: string]: SelectorDefinition<TState, any>;
}

// @public
export function setReduxStoreForSimplux<TState>(storeToUse: Store<TState>, simpluxStateGetter: (rootState: TState) => any): () => void;

// Warning: (ae-forgotten-export) The symbol "EffectMetadata" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type SimpluxEffect<TFunction extends (...args: any[]) => any> = TFunction & EffectMetadata;

// @public (undocumented)
export type SimpluxEffects<TEffectDefinitions extends EffectDefinitions> = {
    [effectName in keyof TEffectDefinitions]: SimpluxEffect<TEffectDefinitions[effectName]>;
};

// @public (undocumented)
export interface SimpluxModule<TState> {
    readonly $simpluxInternals: SimpluxModuleInternals<TState>;
    readonly getState: () => Immutable<TState>;
    readonly setState: (state: Immutable<TState>) => void;
    readonly subscribeToStateChanges: SubscribeToStateChanges<TState>;
}

// @public (undocumented)
export interface SimpluxModuleConfig<TState> {
    // (undocumented)
    initialState: TState;
    // (undocumented)
    name: string;
}

// @public
export interface SimpluxModuleInternals<TState> {
    readonly dispatch: (action: AnyAction) => void;
    readonly getReducer: () => Reducer;
    mockStateValue: TState | undefined;
    readonly mutationMocks: {
        [mutationName: string]: (...args: any[]) => TState;
    };
    readonly mutations: MutationDefinitions<TState>;
    readonly name: string;
    readonly selectors: SelectorDefinitions<TState>;
}

// @public (undocumented)
export interface SimpluxMutation<TState, TArgs extends any[]> {
    (...args: TArgs): TState;
    readonly asAction: (...args: TArgs) => {
        type: string;
        args: TArgs;
    };
    readonly mutationName: string;
    readonly owningModule: SimpluxModule<TState>;
    readonly type: string;
    readonly withState: (state: TState, ...args: TArgs) => TState;
}

// @public (undocumented)
export type SimpluxMutations<TState, TMutations extends MutationDefinitions<TState>> = {
    readonly [name in keyof TMutations]: ResolvedMutation<TState, TMutations[name]>;
};

// @public (undocumented)
export interface SimpluxSelector<TState, TArgs extends any[], TReturn> {
    (...args: TArgs): TReturn;
    readonly owningModule: SimpluxModule<TState>;
    readonly selectorName: string;
    readonly withState: (state: Immutable<TState>, ...args: TArgs) => TReturn;
}

// @public (undocumented)
export type SimpluxSelectors<TState, TSelectorDefinitions extends SelectorDefinitions<TState>> = {
    readonly [name in keyof TSelectorDefinitions]: ResolvedSelector<TState, TSelectorDefinitions[name]>;
};

// @public (undocumented)
export interface SimpluxStore {
    // (undocumented)
    dispatch: Store['dispatch'];
    // (undocumented)
    getReducer: <T = any>(name: string) => Reducer<T>;
    // (undocumented)
    getState: () => any;
    // (undocumented)
    rootReducer: Reducer;
    // (undocumented)
    setReducer: <T = any>(name: string, reducer: Reducer<T>) => void;
    // (undocumented)
    subscribe: Store['subscribe'];
}

// @public (undocumented)
export type StateChangeHandler<TState> = (state: Immutable<TState>, previousState: Immutable<TState>) => void;

// @public (undocumented)
export interface StateChangeHandlerOptions {
    // (undocumented)
    shouldSkipInitialInvocation?: boolean;
}

// @public (undocumented)
export interface StateChangeSubscription<TState, THandler extends StateChangeHandler<TState>> extends Subscription {
    // (undocumented)
    handler: ResolvedStateChangeHandler<TState, THandler>;
}

// @public (undocumented)
export type SubscribeToStateChanges<TState> = <THandler extends StateChangeHandler<TState>>(handler: THandler, options?: StateChangeHandlerOptions) => StateChangeSubscription<TState, THandler>;

// @public (undocumented)
export interface Subscription {
    // (undocumented)
    unsubscribe: () => void;
}


// (No @packageDocumentation comment for this package)

```
